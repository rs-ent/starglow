generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

generator dbml {
  provider = "prisma-dbml-generator"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String                  @id @default(cuid())
  name                   String?
  email                  String?                 @unique
  emailVerified          DateTime?
  password               String?
  phone                  String?
  image                  String?
  role                   String                  @default("user")
  active                 Boolean                 @default(true)
  createdAt              DateTime                @default(now())
  lastLoginAt            DateTime?
  provider               String?
  telegramId             String?                 @unique
  accounts               Account[]
  collectionParticipants CollectionParticipant[]
  loginAttempts          LoginAttemptLog[]       @relation("UserLoginAttempts")
  payments               Payment[]
  player                 Player?
  sessions               Session[]
  wallets                Wallet[]
  discordId              String?
  discordCode            DiscordCode[]

  @@index([telegramId])
  @@index([email, active])
  @@index([role, active])
  @@index([lastLoginAt])
  @@index([createdAt])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId, provider])
}

model DiscordAccount {
  id                String  @id @default(cuid())
  discordId         String  @unique
  userIds           String[]
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([discordId])
  @@index([userIds])
  @@index([createdAt])
  @@index([updatedAt])
}

model DiscordCode {
  id                String  @id @default(cuid())
  code              String  @unique
  expiresAt         DateTime
  userId            String
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  

  @@index([code])
  @@index([expiresAt])
  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique(map: "Session_sessionToken_unique")
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expires])
}

model Wallet {
  id             String       @id @default(cuid())
  userId         String
  address        String       @unique
  privateKey     String?
  network        String
  provider       String       @default("starglow")
  createdAt      DateTime     @default(now())
  default        Boolean      @default(false)
  primary        Int?         @default(0)
  lastAccessedAt DateTime     @updatedAt
  nickname       String?
  status         WalletStatus @default(ACTIVE)
  keyHash        String?
  nonce          String?
  payments       Payment[]
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, network, default])
  @@index([address, network])
  @@index([status])
  @@index([createdAt])
}

model Player {
  id                  String               @id @default(cuid())
  userId              String?              @unique
  telegramId          String?              @unique
  tweetAuthorId       String?              @unique
  tweetVerified       Boolean              @default(false)
  name                String?
  nickname            String?
  image               String?
  email               String?
  referralCount       Int                  @default(0)
  referredBy          String?
  referredMethod      String?
  referredAt          DateTime             @default(now())
  createdAt           DateTime             @default(now())
  lastConnectedAt     DateTime             @updatedAt
  referralCode        String               @unique
  artistFeedReactions ArtistFeedReaction[]
  referrer            Player?              @relation("Referrer", fields: [referredBy], references: [id])
  referredPlayers     Player[]             @relation("Referrer")
  tweetAuthor         TweetAuthor?         @relation("PlayerToTweetAuthor", fields: [tweetAuthorId], references: [authorId])
  user                User?                @relation(fields: [userId], references: [id], onDelete: Cascade)
  playerAssets        PlayerAsset[]
  pollLogs            PollLog[]
  questLogs           QuestLog[]
  referredPlayerLogs  ReferralLog[]        @relation("ReferredPlayer")
  referrerPlayerLogs  ReferralLog[]        @relation("ReferrerPlayer")
  rewardLogs          RewardsLog[]

  @@unique([userId, telegramId])
  @@index([userId, telegramId])
  @@index([referredBy])
  @@index([referralCode])
  @@index([createdAt])
  @@index([lastConnectedAt])
}

model PlayerOldData {
  id                 String   @id @default(cuid())
  telegramId         String   @unique
  name               String?
  points             Int      @default(0)
  referrerTelegramId String?
  createdAt          DateTime @default(now())
}

model ReferralLog {
  id               String   @id @default(cuid())
  referredPlayerId String
  referrerPlayerId String
  method           String?
  createdAt        DateTime @default(now())
  referredPlayer   Player   @relation("ReferredPlayer", fields: [referredPlayerId], references: [id], onDelete: Cascade)
  referrerPlayer   Player   @relation("ReferrerPlayer", fields: [referrerPlayerId], references: [id], onDelete: Cascade)

  @@unique([referredPlayerId, referrerPlayerId])
  @@index([referrerPlayerId])
}

model PlayerAsset {
  id        String            @id @default(cuid())
  playerId  String
  assetId   String
  balance   Int               @default(0)
  status    PlayerAssetStatus @default(ACTIVE)
  updatedAt DateTime          @updatedAt
  asset     Asset             @relation(fields: [assetId], references: [id], onDelete: Cascade)
  player    Player            @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([playerId, assetId])
  @@index([playerId])
  @@index([assetId])
  @@index([status])
}

model Quest {
  id                 String       @id @default(cuid())
  title              String
  questType          QuestType    @default(URL)
  description        String?
  url                String?
  urls               String[]
  icon               String?
  imgUrl             String?
  youtubeUrl         String?
  rewardAssetId      String?
  rewardAmount       Int?
  startDate          DateTime?
  endDate            DateTime?
  needToken          Boolean      @default(false)
  needTokenAddress   String?
  repeatable         Boolean      @default(false)
  repeatableCount    Int?
  repeatableInterval Int?
  multiClaimable     Boolean      @default(false)
  multiClaimLimit    Int?
  multiClaimInterval Int?
  isReferral         Boolean      @default(false)
  referralCount      Int?
  permanent          Boolean      @default(false)
  isActive           Boolean      @default(true)
  order              Int?         @default(0)
  effects            String?
  type               String?
  artistId           String?
  artist             Artist?      @relation("ArtistQuests", fields: [artistId], references: [id])
  rewardAsset        Asset?       @relation("QuestRewardAsset", fields: [rewardAssetId], references: [id])
  questLogs          QuestLog[]
  rewardLogs         RewardsLog[]

  @@index([permanent, isActive, startDate])
  @@index([type, isActive])
  @@index([order, isActive])
  @@index([artistId, isActive])
  @@index([questType, isActive])
}

model QuestLog {
  id             String       @id @default(cuid())
  playerId       String
  questId        String
  completed      Boolean      @default(false)
  completedAt    DateTime?
  rewardAssetId  String?
  rewardAmount   Int?
  repeatCount    Int          @default(1)
  completedDates DateTime[]
  reclaimable    Boolean      @default(false)
  claimedDates   DateTime[]
  deprecated     Boolean      @default(false)
  createdAt      DateTime     @default(now())
  isClaimed      Boolean      @default(false)
  claimedAt      DateTime?
  player         Player       @relation(fields: [playerId], references: [id], onDelete: Cascade)
  quest          Quest        @relation(fields: [questId], references: [id])
  rewardAsset    Asset?       @relation("QuestLogRewardAsset", fields: [rewardAssetId], references: [id])
  rewardLogs     RewardsLog[]

  @@unique([playerId, questId])
  @@index([playerId, questId, deprecated])
  @@index([completedAt])
}

model Poll {
  id                         String       @id @default(cuid())
  title                      String
  titleShorten               String?
  description                String?
  category                   PollCategory @default(PUBLIC)
  status                     PollStatus   @default(UPCOMING)
  isActive                   Boolean      @default(false)
  options                    Json[]
  optionsOrder               String[]     @default([])
  hasAnswer                  Boolean      @default(false)
  answerOptionIds            String[]     @default([])
  imgUrl                     String?
  youtubeUrl                 String?
  startDate                  DateTime     @default(now())
  endDate                    DateTime
  exposeInScheduleTab        Boolean      @default(true)
  hideResults                Boolean      @default(false)
  resultVisibleDate          DateTime?
  prePromoText               String?
  prePromoImg                String?
  postPromoText              String?
  postPromoImg               String?
  needToken                  Boolean      @default(true)
  needTokenAddress           String?
  minimumPoints              Int?
  minimumSGP                 Int?
  minimumSGT                 Int?
  requiredQuests             String[]     @default([])
  allowMultipleVote          Boolean      @default(false)
  voteLimit                  Int?
  bettingMode                Boolean      @default(false)
  bettingAssetId             String?
  minimumBet                 Int          @default(1000)
  maximumBet                 Int          @default(10000)
  participationRewardAssetId String?
  participationRewardAmount  Int?
  viewCount                  Int          @default(0)
  uniqueVoters               Int          @default(0)
  totalVotes                 Int          @default(0)
  totalBetsAmount            Int          @default(0)
  customResults              Int[]        @default([])
  verificationHash           String?
  verifiedAt                 DateTime?
  verifiedBy                 String?
  tags                       String[]     @default([])
  metadata                   Json?
  createdAt                  DateTime     @default(now())
  updatedAt                  DateTime     @updatedAt
  artistId                   String?
  artist                     Artist?      @relation("ArtistPolls", fields: [artistId], references: [id])
  bettingAsset               Asset?       @relation("PollBettingAsset", fields: [bettingAssetId], references: [id])
  participationRewardAsset   Asset?       @relation("PollParticipationReward", fields: [participationRewardAssetId], references: [id])
  pollLogs                   PollLog[]
  rewardLogs                 RewardsLog[]

  @@index([category])
  @@index([artistId])
  @@index([status, startDate])
  @@index([isActive, startDate])
}

model PollLog {
  id            String       @id @default(cuid())
  playerId      String
  pollId        String
  optionId      String
  option        Json
  amount        Int          @default(1)
  betAmount     Int          @default(0)
  ipAddress     String?
  userAgent     String?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  rewardAssetId String?
  rewardAmount  Int?
  record        Json?
  player        Player       @relation(fields: [playerId], references: [id], onDelete: Cascade)
  poll          Poll         @relation(fields: [pollId], references: [id])
  rewardAsset   Asset?       @relation("PollLogRewardAsset", fields: [rewardAssetId], references: [id])
  rewardLogs    RewardsLog[]

  @@unique([playerId, pollId, optionId])
  @@index([playerId])
  @@index([pollId])
  @@index([playerId, pollId])
}

model RewardsLog {
  id            String    @id @default(cuid())
  playerId      String
  assetId       String?
  balanceBefore Int?
  balanceAfter  Int?
  questId       String?
  questLogId    String?
  pollId        String?
  pollLogId     String?
  amount        Int
  reason        String?
  createdAt     DateTime  @default(now())
  asset         Asset?    @relation(fields: [assetId], references: [id])
  player        Player    @relation(fields: [playerId], references: [id], onDelete: Cascade)
  poll          Poll?     @relation(fields: [pollId], references: [id])
  pollLog       PollLog?  @relation(fields: [pollLogId], references: [id])
  quest         Quest?    @relation(fields: [questId], references: [id])
  questLog      QuestLog? @relation(fields: [questLogId], references: [id])
  tweetAuthorId String?
  tweetAuthor   TweetAuthor? @relation(fields: [tweetAuthorId], references: [id])
  tweetIds      String[]

  @@index([playerId, pollId])
  @@index([playerId, questId])
  @@index([playerId, assetId])
  @@index([questId, pollId])
  @@index([tweetAuthorId])
  @@index([tweetAuthorId, reason])
  @@index([tweetIds])
}

model Events {
  id              String        @id @default(cuid())
  category        EventCategory @default(other)
  title           String
  description     String?
  content         Json?
  url             String?
  status          EventStatus   @default(upcoming)
  bannerImg       String?
  bannerImg2      String?
  galleryImgs     String[]      @default([])
  detailImg       Json?
  saleStartDate   DateTime?
  saleEndDate     DateTime?
  price           Int?
  capacity        Int?
  ageLimit        Int?
  organizer       String?
  organizerImg    String?
  organizerUrl    String?
  contact         String?
  startDate       DateTime
  endDate         DateTime
  location        String?
  locationAddress String?
  locationImg     String?
  locationUrl     String?
  locationLat     Float?
  locationLng     Float?
  artist          String?
  artistImg       String?
  artistUrl       String?
  tags            String[]      @default([])
  hashtags        String[]      @default([])
  promotionText   String?
  promotionImg    String?
  isFeatured      Boolean       @default(false)
  viewCount       Int           @default(0)
  bookmarkCount   Int           @default(0)
  isActive        Boolean       @default(true)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([category, status, startDate])
  @@index([location, startDate])
  @@index([isFeatured, isActive, startDate])
  @@index([artistUrl])
  @@index([createdAt])
}

model StoredFiles {
  id        String    @id @default(cuid())
  name      String?   @db.VarChar(255)
  url       String    @unique @db.VarChar(2048)
  type      String?   @db.VarChar(50)
  sourceUrl String?   @db.VarChar(2048)
  alt       String?   @db.VarChar(255)
  width     Int?
  height    Int?
  mimeType  String?   @db.VarChar(50)
  sizeBytes Int?
  metadata  Json?
  order     Int?      @default(0)
  purpose   String?   @db.VarChar(50)
  bucket    String    @db.VarChar(50)
  focusX    Float     @default(0.5)
  focusY    Float     @default(0.5)
  expiresAt DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@unique([sourceUrl, type])
  @@index([bucket, purpose])
  @@index([url, type])
  @@index([url])
}

model LoginAttemptLog {
  id        String   @id @default(cuid())
  userId    String?
  email     String?
  provider  String?
  success   Boolean
  error     String?
  ipAddress String?
  userAgent String?
  timestamp DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User?    @relation("UserLoginAttempts", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, success, timestamp])
  @@index([email, success, timestamp])
  @@index([provider, success, timestamp])
  @@index([ipAddress, timestamp])
}

model Payment {
  id                     String            @id @default(cuid())
  userId                 String?
  productTable           String
  productId              String
  productName            String
  productDefaultCurrency String
  amount                 Int
  quantity               Int
  currency               String
  payMethod              String
  easyPayProvider        String?
  cardProvider           String?
  cardInstallmentMonths  Int?
  cardInterestFree       Boolean?
  cardApproveNumber      String?
  cardNumber             String?
  status                 PaymentStatus     @default(PENDING)
  statusReason           String?
  paidAt                 DateTime?
  cancelledAt            DateTime?
  failedAt               DateTime?
  pgResponse             Json?
  metadata               Json?
  createdAt              DateTime          @default(now())
  updatedAt              DateTime          @updatedAt
  channelKey             String
  storeId                String
  promotionCode          String?
  isPromotionApplied     Boolean           @default(false)
  convertedPrice         Int?
  exchangeRate           Float?
  exchangeRateProvider   String?
  exchangeRateTimestamp  DateTime?
  originalProductPrice   Int?
  refundedAt             DateTime?
  cancelAmount           Int?
  redirectUrl            String?
  code                   String?
  message                String?
  paymentId              String?
  pgCode                 String?
  pgMessage              String?
  transactionType        String?
  txId                   String?
  postProcessResult      Json?
  postProcessResultAt    DateTime?
  receiverWalletAddress  String?
  needWallet             Boolean           @default(false)
  completedAt            DateTime?
  promotion              PaymentPromotion? @relation(fields: [promotionCode], references: [code])
  receiverWallet         Wallet?           @relation(fields: [receiverWalletAddress], references: [address])
  user                   User?             @relation(fields: [userId], references: [id])
  virtualAccount         VirtualAccount?
  webhookEvents          WebhookEvent[]

  @@index([userId])
  @@index([userId, status])
  @@index([status, createdAt])
  @@index([productTable, productId])
  @@index([channelKey])
  @@index([paymentId])
  @@index([createdAt])
}

model PaymentPromotion {
  id            String                       @id @default(cuid())
  code          String                       @unique
  startDate     DateTime
  endDate       DateTime
  discountType  PaymentPromotionDiscountType @default(percentage)
  discountValue Int
  isActive      Boolean                      @default(true)
  createdAt     DateTime                     @default(now())
  updatedAt     DateTime                     @updatedAt
  payments      Payment[]

  @@index([code])
}

model WebhookEvent {
  id          String   @id @default(cuid())
  paymentId   String?
  payload     Json?
  createdAt   DateTime @default(now())
  description String?
  payment     Payment? @relation(fields: [paymentId], references: [id], onDelete: Cascade)
}

model VirtualAccount {
  id            String    @id @default(cuid())
  paymentId     String    @unique
  bankCode      String
  accountNumber String
  holderName    String
  expiresAt     DateTime
  depositedAt   DateTime?
  depositorName String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  payment       Payment   @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@index([accountNumber])
}

model ExchangeRate {
  id           String   @id @default(cuid())
  fromCurrency String
  toCurrency   String
  rate         Float
  provider     String
  createdAt    DateTime @default(now())

  @@index([fromCurrency, toCurrency])
}

model BlockchainNetwork {
  id                  String               @id @default(cuid())
  name                String               @unique
  chainId             Int                  @unique
  rpcUrl              String
  explorerUrl         String
  symbol              String
  isTestnet           Boolean              @default(true)
  isActive            Boolean              @default(true)
  isStoryNetwork      Boolean              @default(false)
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  multicallAddress    String?
  defaultNetwork      Boolean              @default(false)
  assets              Asset[]
  assetsContracts     AssetsContract[]
  collectionContracts CollectionContract[]
  factoryContracts    FactoryContract[]
  nfts                NFT[]
  story_ipAssets      Story_ipAsset[]
  story_nfts          Story_nft[]
  story_spg           Story_spg[]
  story_spg_contracts Story_spgContract[]
  tbaContracts        TBAContract[]

  @@index([isTestnet, isActive])
  @@index([isStoryNetwork])
  @@index([isTestnet, isActive, isStoryNetwork])
}

model AssetsContract {
  id             String            @id @default(cuid())
  address        String            @unique
  version        String
  description    String?
  abi            Json?
  bytecode       String?
  networkId      String
  creatorAddress String?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  assets         Asset[]
  network        BlockchainNetwork @relation(fields: [networkId], references: [id])

  @@index([networkId])
}

model Asset {
  id                            String             @id @default(cuid())
  name                          String
  symbol                        String
  description                   String?
  iconUrl                       String?
  imageUrl                      String?
  metadata                      Json?
  assetType                     AssetType
  contractAddress               String?
  isActive                      Boolean            @default(true)
  isDefault                     Boolean            @default(false)
  selectors                     String[]           @default([])
  abis                          Json?
  creatorAddress                String?
  assetId                       String?
  assetsContractAddress         String?
  networkId                     String?
  createdAt                     DateTime           @default(now())
  updatedAt                     DateTime           @updatedAt
  assetsContract                AssetsContract?    @relation(fields: [assetsContractAddress], references: [address])
  network                       BlockchainNetwork? @relation(fields: [networkId], references: [id])
  playerAssets                  PlayerAsset[]
  pollBettingAssets             Poll[]             @relation("PollBettingAsset")
  pollParticipationRewardAssets Poll[]             @relation("PollParticipationReward")
  pollLogRewardAssets           PollLog[]          @relation("PollLogRewardAsset")
  questRewardAssets             Quest[]            @relation("QuestRewardAsset")
  questLogRewardAssets          QuestLog[]         @relation("QuestLogRewardAsset")
  rewardsLogs                   RewardsLog[]
  stakeRewards                  StakeReward[]      @relation("StakeReward")
  stakeRewardLogs               StakeRewardLog[]   @relation("StakeRewardLog")

  @@index([isDefault])
  @@index([assetType, isActive])
  @@index([contractAddress])
  @@index([networkId])
}

model AssetTransaction {
  id              String   @id @default(cuid())
  success         Boolean
  assetId         String
  description     String?
  metadata        Json?
  amount          Int?
  receiverAddress String?
  transactionHash String   @unique
  createdAt       DateTime @default(now())

  @@index([assetId, success])
  @@index([transactionHash])
}

model FactoryContract {
  id                  String               @id @default(cuid())
  address             String
  networkId           String
  deployedAt          DateTime             @default(now())
  deployedBy          String?
  transactionHash     String?
  isActive            Boolean              @default(true)
  collections         String[]             @default([])
  abi                 Json?
  bytecode            String?
  collectionContracts CollectionContract[]
  network             BlockchainNetwork    @relation(fields: [networkId], references: [id])

  @@unique([address, networkId])
  @@index([networkId, isActive])
}

model EscrowWallet {
  id         String   @id @default(cuid())
  address    String   @unique
  privateKey String
  keyHash    String
  networkIds String[] @default([])
  isActive   Boolean  @default(true)
  balance    Json?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  nonce      String

  @@index([isActive])
}

model ipfs {
  id               String   @id @default(cuid())
  cid              String   @unique
  url              String   @unique
  type             String   @default("default")
  previewUrl       String?
  previewWidth     Int?
  previewHeight    Int?
  previewMimeType  String?
  previewSizeBytes Int?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([type])
  @@index([previewUrl])
}

model Metadata {
  id                 String              @id @default(cuid())
  metadata           Json
  url                String              @default("ipfs://")
  collectionAddress  String?             @unique
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  type               MetadataType        @default(collection)
  tokenId            Int?
  collectionKey      String
  collectionContract CollectionContract? @relation("CollectionContractMetadata", fields: [collectionAddress], references: [address])

  @@unique([collectionAddress, tokenId])
  @@index([collectionAddress, tokenId])
  @@index([collectionAddress])
  @@index([url])
}

model CollectionContract {
  id             String                  @id @default(cuid())
  address        String                  @unique
  name           String
  symbol         String
  maxSupply      Int
  mintPrice      String
  baseURI        String
  contractURI    String
  factoryId      String
  networkId      String
  createdBy      String                  @default("admin")
  creatorAddress String                  @default("0x58E1F072A8f41e1d476F06d73a6cB7b866e6f63B")
  txHash         String?
  createdAt      DateTime                @default(now())
  updatedAt      DateTime                @updatedAt
  price          Int                     @default(0)
  circulation    Int                     @default(1000)
  mintedCount    Int                     @default(0)
  artistId       String?
  key            String                  @unique
  isListed       Boolean                 @default(false)
  abi            Json?
  bytecode       String?
  isPaused       Boolean                 @default(false)
  pauseAt        DateTime?
  unpauseAt      DateTime?
  preSaleStart   DateTime?
  preSaleEnd     DateTime?
  saleStart      DateTime?
  saleEnd        DateTime?
  glowStart      DateTime?
  glowEnd        DateTime?
  pageImages     String[]
  artist         Artist?                 @relation(fields: [artistId], references: [id])
  factory        FactoryContract         @relation(fields: [factoryId], references: [id])
  network        BlockchainNetwork       @relation(fields: [networkId], references: [id])
  participants   CollectionParticipant[]
  metadata       Metadata?               @relation("CollectionContractMetadata")
  nfts           NFT[]
  events         NFTEvent[]
  stakeRewards   StakeReward[]           @relation("StakeReward")

  @@index([address, networkId])
  @@index([factoryId])
}

model NFT {
  id                  String             @id @default(cuid())
  tokenId             Int
  collectionId        String
  ownerAddress        String
  metadataUri         String?
  mintedAt            DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  transactionHash     String
  networkId           String
  name                String?
  description         String?
  imageUrl            String?
  attributes          Json?
  isListed            Boolean            @default(false)
  listingPrice        String?
  lastTransferredAt   DateTime?
  transferCount       Int                @default(0)
  isBurned            Boolean            @default(false)
  rarity              Float?
  tags                String[]
  category            String?
  creatorInfo         String?
  externalUrl         String?
  mintPrice           String?
  mintedBy            String?
  royaltyInfo         Json?
  currentOwnerAddress String?
  isLocked            Boolean            @default(false)
  lockedAt            DateTime?
  unlockAt            DateTime?
  unlockScheduledAt   DateTime?
  lockTransactionHash String?
  isStaked            Boolean            @default(false)
  stakedAt            DateTime?
  unstakeScheduledAt  DateTime?
  unstakedAt          DateTime?
  collection          CollectionContract @relation(fields: [collectionId], references: [id])
  network             BlockchainNetwork  @relation(fields: [networkId], references: [id])
  events              NFTEvent[]
  stakeRewardLogs     StakeRewardLog[]   @relation("StakeRewardLog")

  @@unique([collectionId, tokenId])
  @@index([collectionId, tokenId])
  @@index([collectionId])
  @@index([tokenId])
  @@index([currentOwnerAddress])
  @@index([ownerAddress])
  @@index([isStaked, stakedAt])
  @@index([isListed])
  @@index([mintedAt])
}

model CollectionParticipant {
  id                String                    @id @default(cuid())
  type              CollectionParticipantType
  userId            String
  collectionAddress String
  createdAt         DateTime                  @default(now())
  collection        CollectionContract        @relation(fields: [collectionAddress], references: [address])
  user              User                      @relation(fields: [userId], references: [id])

  @@unique([userId, collectionAddress, type])
  @@index([collectionAddress, type])
}

model StakeReward {
  id                String             @id @default(cuid())
  assetId           String
  amount            Int
  stakeDuration     BigInt
  collectionAddress String
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  asset             Asset              @relation("StakeReward", fields: [assetId], references: [id])
  collection        CollectionContract @relation("StakeReward", fields: [collectionAddress], references: [address])
  stakeRewardLogs   StakeRewardLog[]   @relation("StakeRewardLog")
}

model StakeRewardLog {
  id            String      @id @default(cuid())
  stakeRewardId String
  nftId         String
  assetId       String
  amount        Int
  isDistributed Boolean     @default(false)
  distributedAt DateTime?
  isClaimed     Boolean     @default(false)
  claimedAt     DateTime?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  asset         Asset       @relation("StakeRewardLog", fields: [assetId], references: [id])
  nft           NFT         @relation("StakeRewardLog", fields: [nftId], references: [id])
  stakeReward   StakeReward @relation("StakeRewardLog", fields: [stakeRewardId], references: [id])

  @@index([stakeRewardId])
  @@index([nftId])
}

model NFTEvent {
  id              String             @id @default(cuid())
  nftId           String
  collectionId    String
  eventType       String
  fromAddress     String?
  toAddress       String?
  price           String?
  transactionHash String
  timestamp       DateTime           @default(now())
  blockNumber     Int?
  collection      CollectionContract @relation(fields: [collectionId], references: [id])
  nft             NFT                @relation(fields: [nftId], references: [id])

  @@index([nftId])
  @@index([eventType])
  @@index([fromAddress, toAddress])
}

model Artist {
  id                  String               @id @default(cuid())
  name                String
  description         String?
  logoUrl             String?
  imageUrl            String?
  externalUrl         String?
  reportUrl           String?
  company             String?
  sns                 String[]             @default([])
  gallery             String[]             @default([])
  videos              String[]             @default([])
  music               String[]             @default([])
  events              String[]             @default([])
  additionalInfo      Json?
  backgroundColors    String[]             @default([])
  foregroundColors    String[]             @default([])
  code                String?              @unique
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  feeds               ArtistFeed[]
  members             ArtistMember[]
  messages            ArtistMessage[]
  collectionContracts CollectionContract[]
  polls               Poll[]               @relation("ArtistPolls")
  quests              Quest[]              @relation("ArtistQuests")
  story_spg           Story_spg[]

  @@index([name])
  @@index([code])
}

model ArtistMember {
  id             String    @id @default(cuid())
  artistId       String
  name           String
  role           String
  imageUrl       String?
  externalUrl    String?
  description    String?
  realName       String?
  birthDate      DateTime?
  birthPlace     String?
  nationality    String?
  height         Int?
  weight         Int?
  bloodType      String?
  constellation  String?
  sns            String[]  @default([])
  gallery        String[]  @default([])
  videos         String[]  @default([])
  music          String[]  @default([])
  additionalInfo Json?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  artist         Artist    @relation(fields: [artistId], references: [id])
}

model ArtistMessage {
  id          String    @id @default(cuid())
  artistId    String
  bannerUrl   String?
  externalUrl String?
  isActive    Boolean   @default(true)
  startDate   DateTime?
  endDate     DateTime?
  message     String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  artist      Artist    @relation(fields: [artistId], references: [id])
}

model ArtistFeed {
  id        String               @id @default(cuid())
  artistId  String
  imageUrls String[]
  videoUrls String[]
  text      String?
  createdAt DateTime             @default(now())
  updatedAt DateTime             @updatedAt
  artist    Artist               @relation(fields: [artistId], references: [id])
  reactions ArtistFeedReaction[]

  @@index([artistId, createdAt])
}

model ArtistFeedReaction {
  id           String     @id @default(cuid())
  artistFeedId String
  playerId     String
  reaction     String
  comment      String?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  artistFeed   ArtistFeed @relation(fields: [artistFeedId], references: [id])
  player       Player     @relation(fields: [playerId], references: [id])

  @@unique([artistFeedId, playerId, reaction])
}

model Story_spgContract {
  id        String            @id @default(cuid())
  address   String            @unique
  abi       Json?
  bytecode  String?
  txHash    String?
  networkId String
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  story_spg Story_spg[]
  network   BlockchainNetwork @relation(fields: [networkId], references: [id])

  @@index([networkId])
}

model TBAContract {
  id         String            @id @default(cuid())
  address    String            @unique
  type       TBAContractType
  name       String?
  version    String?
  abi        Json?
  bytecode   String?
  txHash     String?
  deployedBy String?
  networkId  String
  isActive   Boolean           @default(true)
  createdAt  DateTime          @default(now())
  updatedAt  DateTime          @updatedAt
  network    BlockchainNetwork @relation(fields: [networkId], references: [id])

  @@unique([networkId, type, address])
  @@index([networkId, type])
  @@index([networkId, type, isActive])
}

model Story_spg {
  id                       String             @id @default(cuid())
  address                  String             @unique
  baseURI                  String
  contractURI              String
  name                     String             @unique
  symbol                   String             @unique
  imageUrl                 String?
  metadata                 Json?
  createdAt                DateTime           @default(now())
  updatedAt                DateTime           @updatedAt
  contractAddress          String?
  networkId                String
  ownerAddress             String
  artistId                 String?
  tbaRegistryAddress       String?
  tbaImplementationAddress String?
  isListed                 Boolean            @default(false)
  reportUrl                String?
  sharePercentage          Float              @default(0.0)
  preOrderStart            DateTime?
  preOrderEnd              DateTime?
  saleStart                DateTime?
  saleEnd                  DateTime?
  glowStart                DateTime?
  glowEnd                  DateTime?
  price                    Int                @default(0)
  circulation              Int                @default(1000)
  pageImages               String[]
  backgroundColor          String?
  foregroundColor          String?
  story_nfts               Story_nft[]
  artist                   Artist?            @relation(fields: [artistId], references: [id])
  contract                 Story_spgContract? @relation(fields: [contractAddress], references: [address])
  network                  BlockchainNetwork  @relation(fields: [networkId], references: [id])

  @@index([networkId])
  @@index([ownerAddress])
  @@index([ownerAddress, networkId])
  @@index([address])
  @@index([name])
  @@index([symbol])
  @@index([artistId])
  @@index([tbaRegistryAddress])
  @@index([tbaImplementationAddress])
}

model Story_nft {
  id              String            @id @default(cuid())
  tokenId         String
  ownerAddress    String
  networkId       String
  tokenURI        String
  tokenURICid     String
  mintTxHash      String?
  contractAddress String
  ipId            String?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  spgCollection   Story_spg         @relation(fields: [contractAddress], references: [address])
  ipAsset         Story_ipAsset?    @relation(fields: [ipId], references: [ipId])
  network         BlockchainNetwork @relation(fields: [networkId], references: [id])

  @@unique([contractAddress, tokenId])
  @@index([contractAddress])
  @@index([ownerAddress])
  @@index([networkId])
  @@index([ipId])
}

model Story_ipAsset {
  id                 String            @id @default(cuid())
  ipId               String            @unique
  chainId            String
  tokenContract      String
  tokenId            String
  ipMetadataURI      String?
  ipMetadataHash     String?
  nftMetadataURI     String?
  nftMetadataHash    String?
  registrationTxHash String?
  licenseTermsId     String?
  licenseTermsURI    String?
  networkId          String
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  network            BlockchainNetwork @relation(fields: [networkId], references: [id])
  nfts               Story_nft[]

  @@unique([chainId, tokenContract, tokenId])
  @@index([ipId])
  @@index([networkId])
}

model TweetAuthor {
  id String @id @default(cuid())
  authorId String @unique
  name String?
  username String?
  profileImageUrl String?

  validated Boolean @default(false)
  validatedAt DateTime?
  registered Boolean @default(false)
  registeredAt DateTime?
  
  tweets Tweet[]
  player Player? @relation("PlayerToTweetAuthor")
  metrics TweetAuthorMetrics[]
  isBlacklisted Boolean @default(false)
  blacklistedAt DateTime?
  blacklistData TweetAuthorBlacklist?

  rewardsLogs RewardsLog[]

  @@index([authorId])
  @@index([isBlacklisted])
}

model TweetAuthorMetrics {
  id String @id @default(cuid())
  tweetAuthorId String
  tweetAuthor TweetAuthor @relation(fields: [tweetAuthorId], references: [authorId])
  
  followersCount Int
  followingCount Int
  tweetCount Int
  listedCount Int
  verified Boolean @default(false)
  
  recordedAt DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tweetAuthorId])
}

model TweetAuthorBlacklist {
  id String @id @default(cuid())
  authorId String @unique
  author TweetAuthor @relation(fields: [authorId], references: [authorId])

  reason String?
  tweetCount Int @default(0)
  periodStart DateTime?
  periodEnd DateTime?
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isActive])
}


model Tweet {
  id                    String         @id @default(cuid())
  tweetId               String         @unique
  text                  String
  authorName            String?
  authorUsername        String?
  authorProfileImageUrl String?
  authorId              String
  isDeleted             Boolean        @default(false)
  deletedAt             DateTime?
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
  author                TweetAuthor    @relation(fields: [authorId], references: [authorId])
  media                 TweetMedia[]
  metricsHistory        TweetMetrics[]

  @@index([authorId])
  @@index([tweetId])
  @@index([createdAt])
  @@index([isDeleted])
}

model TweetMetrics {
  id           String   @id @default(cuid())
  tweetId      String
  replyCount   Int
  retweetCount Int
  likeCount    Int
  quoteCount   Int
  recordedAt   DateTime @default(now())
  tweet        Tweet    @relation(fields: [tweetId], references: [tweetId])

  @@index([tweetId, recordedAt])
  @@index([recordedAt])
}

model TweetMedia {
  id              String   @id @default(cuid())
  mediaKey        String   @unique
  tweetId         String
  type            String
  url             String?
  previewImageUrl String?
  width           Int?
  height          Int?
  durationMs      Int?
  altText         String?
  createdAt       DateTime @default(now())
  tweet           Tweet    @relation(fields: [tweetId], references: [tweetId])

  @@index([tweetId])
  @@index([mediaKey])
}

model TweetSyncData {
  id                 Int             @id @default(autoincrement())
  lastTweetId        String?
  lastSyncAt         DateTime        @default(now())
  syncStatus         String          @default("success")
  errorMessage       String?
  totalTweetsFound   Int             @default(0)
  newTweetsAdded     Int             @default(0)
  apiRequestsUsed    Int             @default(0)
  rateLimitRemaining Int?
  executionTimeMs    Int?
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  tweetResponses     TweetResponse[]

  @@index([lastSyncAt])
}

model TweetResponse {
  id               String        @id @default(cuid())
  tweetSyncDataId  Int
  rawResponse      Json
  requestParams    Json
  responseCode     Int
  requestTimestamp DateTime      @default(now())
  processingTimeMs Int?
  tweetSyncData    TweetSyncData @relation(fields: [tweetSyncDataId], references: [id], onDelete: Cascade)

  @@index([tweetSyncDataId])
  @@index([requestTimestamp])
}

model XAuthSession {
  id           String   @id @default(cuid())
  state        String   @unique
  codeVerifier String
  playerId     String
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  
  @@index([expiresAt])
}

enum PlayerAssetStatus {
  ACTIVE
  INACTIVE
  DELETED
  FROZEN
}

enum QuestType {
  URL
  REFERRAL
}

enum PollStatus {
  UPCOMING
  ACTIVE
  ENDED
  CANCELLED
  CALCULATING_RESULTS
}

enum PollCategory {
  PUBLIC
  PRIVATE
}

enum AssetType {
  ONCHAIN
  OFFCHAIN
}

enum CollectionParticipantType {
  PREREGISTRATION
  PRESALE
  PRIVATESALE
  PUBLICSALE
  GLOW
}

enum TBAContractType {
  REGISTRY
  IMPLEMENTATION
}

enum PaymentStatus {
  PENDING
  AWAITING_DEPOSIT
  PAID
  CANCELLED
  FAILED
  EXPIRED
  PARTIALLY_CANCELLED
  REFUNDED
  COMPLETED
}

enum PaymentPromotionDiscountType {
  percentage
  amount
}

enum RewardCurrency {
  points
  SGP
  SGT
}

enum EventCategory {
  concert
  fanmeeting
  fancamp
  festival
  exhibition
  other
}

enum EventStatus {
  upcoming
  ongoing
  completed
  cancelled
}

enum WalletStatus {
  ACTIVE
  INACTIVE
  LOCKED
}

enum MetadataType {
  collection
  nft
}
