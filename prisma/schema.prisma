generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

generator dbml {
  provider = "prisma-dbml-generator"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id            String            @id @default(cuid())
  name          String?
  email         String?           @unique
  emailVerified DateTime?
  image         String?
  role          String            @default("user")
  active        Boolean           @default(true)
  createdAt     DateTime          @default(now())
  lastLoginAt   DateTime?
  accounts      Account[]
  loginAttempts LoginAttemptLog[] @relation("UserLoginAttempts")
  payments      Payment[]
  player        Player?
  sessions      Session[]
  wallets       Wallet[]

  @@index([email, active])
  @@index([role, active])
  @@index([lastLoginAt])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId, provider])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique(map: "Session_sessionToken_unique")
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expires])
}

model Wallet {
  id             String       @id @default(cuid())
  userId         String
  address        String       @unique
  privateKey     String?
  network        String
  createdAt      DateTime     @default(now())
  default        Boolean      @default(false)
  primary        Int?         @default(0)
  lastAccessedAt DateTime     @updatedAt
  nickname       String?
  status         WalletStatus @default(ACTIVE)
  keyHash        String?
  nonce          String?
  payments       Payment[]
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, network, default])
  @@index([address, network])
}

model Player {
  id                String       @id @default(cuid())
  userId            String?      @unique
  telegramId        String?      @unique
  name              String?
  referralCount     Int          @default(0)
  referredBy        String?
  referrer          Player?      @relation("Referrer", fields: [referredBy], references: [id])
  referredPlayers   Player[]     @relation("Referrer")
  referredMethod    String?
  referredAt        DateTime     @default(now())
  createdAt         DateTime     @default(now())
  lastConnectedAt   DateTime     @updatedAt
  user              User?        @relation(fields: [userId], references: [id], onDelete: Cascade)
  playerAssets      PlayerAsset[]
  pollLogs          PollLog[]
  questLogs         QuestLog[]
  rewardLogs        RewardsLog[]
  referredPlayerLogs    ReferralLog[]   @relation("ReferredPlayer")
  referrerPlayerLogs    ReferralLog[]   @relation("ReferrerPlayer")

  @@unique([userId, telegramId])
  @@index([userId, telegramId])
  @@index([referredBy])
}

model ReferralLog {
  id             String         @id @default(cuid())
  referredPlayerId String
  referredPlayer   Player       @relation("ReferredPlayer", fields: [referredPlayerId], references: [id], onDelete: Cascade)
  referrerPlayerId String
  referrerPlayer   Player       @relation("ReferrerPlayer", fields: [referrerPlayerId], references: [id], onDelete: Cascade)
  method           String?
  createdAt      DateTime     @default(now())

  @@unique([referredPlayerId, referrerPlayerId])
}

enum PlayerAssetStatus {
  ACTIVE
  INACTIVE
  DELETED
  FROZEN
}

model PlayerAsset {
  id             String         @id @default(cuid())
  playerId       String
  assetId        String
  balance        Int            @default(0)
  player         Player         @relation(fields: [playerId], references: [id], onDelete: Cascade)
  asset          Asset          @relation(fields: [assetId], references: [id], onDelete: Cascade)
  status         PlayerAssetStatus @default(ACTIVE)
  updatedAt      DateTime       @updatedAt

  @@unique([playerId, assetId])
  @@index([playerId])
  @@index([assetId])
  @@index([status])
}

model Quest {
  id             String         @id @default(cuid())
  title          String
  description    String?
  url            String?
  icon           String?
  imgUrl         String?
  youtubeUrl     String?
  rewardAssetId    String?      
  rewardAmount     Int?
  rewardAsset      Asset?       @relation("QuestRewardAsset", fields: [rewardAssetId], references: [id])
  startDate      DateTime?
  endDate        DateTime?
  needToken         Boolean      @default(false)
  needTokenAddress  String?
  repeatable     Boolean        @default(false)
  repeatableCount Int?
  repeatableInterval Int?
  isReferral     Boolean        @default(false)
  referralCount  Int?
  permanent      Boolean        @default(false)
  isActive       Boolean        @default(true)
  order          Int?           @default(0)
  effects        String?
  type           String?
  questLogs      QuestLog[]
  rewardLogs     RewardsLog[]

  artistId   String?
  artist     Artist?     @relation("ArtistQuests", fields: [artistId], references: [id])

  @@index([permanent, isActive, startDate])
  @@index([type, isActive])
  @@index([order, isActive])
}

model QuestLog {
  id             String         @id @default(cuid())
  playerId       String
  questId        String
  completed      Boolean        @default(false)
  completedAt    DateTime?
  rewardAssetId  String?
  rewardAmount   Int?
  rewardAsset    Asset?         @relation("QuestLogRewardAsset", fields: [rewardAssetId], references: [id])
  repeatCount    Int            @default(1)
  completedDates DateTime[]
  createdAt      DateTime       @default(now())
  isClaimed      Boolean        @default(false)
  claimedAt      DateTime?
  player         Player         @relation(fields: [playerId], references: [id], onDelete: Cascade)
  quest          Quest          @relation(fields: [questId], references: [id])
  rewardLogs     RewardsLog[]

  @@unique([playerId, questId])
  @@index([playerId, questId, completed])
  @@index([completedAt])
}

enum PollStatus {
  UPCOMING
  ACTIVE
  ENDED
  CANCELLED
  CALCULATING_RESULTS
}

enum PollCategory {
  PUBLIC
  PRIVATE
}

model Poll {
  id                String       @id @default(cuid())
  
  // 기본 정보
  title             String
  titleShorten      String?
  description       String?
  category          PollCategory @default(PUBLIC)
  status            PollStatus   @default(UPCOMING)
  
  // 옵션 정보 (JSON 형태로 저장)
  options           Json[]       // [{optionId: string, option: string, optionShorten: string?, description: string?, imgUrl: string?, youtubeUrl: string?}]
  optionsOrder      String[]     @default([]) // [optionId, optionId, optionId, ...]
  
  // 미디어
  imgUrl            String?
  youtubeUrl        String?
  
  // 일정
  startDate         DateTime     @default(now())
  endDate           DateTime
  
  // 노출 설정
  exposeInScheduleTab Boolean    @default(true)
  hideResults        Boolean     @default(false)
  resultVisibleDate  DateTime?
  
  // 프로모션
  prePromoText      String?      // richText
  prePromoImg       String?
  postPromoText     String?      // richText
  postPromoImg      String?
  
  // 참여 조건
  needToken         Boolean      @default(true)
  needTokenAddress  String?
  minimumPoints     Int?
  minimumSGP        Int?
  minimumSGT        Int?
  requiredQuests    String[]     @default([])
  
  // 투표 설정
  allowMultipleVote Boolean      @default(false)
  voteLimit         Int?
  
  // 베팅 설정
  bettingMode       Boolean      @default(false)
  bettingAssetId    String?      
  bettingAsset      Asset?       @relation("PollBettingAsset", fields: [bettingAssetId], references: [id])
  minimumBet        Int          @default(1000)
  maximumBet        Int          @default(10000)

  participationRewardAssetId String?
  participationRewardAmount  Int?
  participationRewardAsset   Asset?    @relation("PollParticipationReward", fields: [participationRewardAssetId], references: [id])
  
  // 통계
  viewCount          Int          @default(0)
  uniqueVoters       Int          @default(0)
  totalVotes         Int          @default(0)
  totalBetsAmount    Int          @default(0)
  customResults      Int[]        @default([])
  
  // 검증
  verificationHash   String?
  verifiedAt        DateTime?
  verifiedBy        String?
  
  // 메타데이터
  tags              String[]      @default([])
  metadata          Json?
  
  // 타임스탬프
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  
  // 관계
  artistId   String?
  artist     Artist?     @relation("ArtistPolls", fields: [artistId], references: [id])
  pollLogs          PollLog[]
  rewardLogs        RewardsLog[]

  // 인덱스
  @@index([status, startDate, endDate])
  @@index([category, status])
  @@index([needToken, status])
  @@index([bettingMode, status])
}

model PollLog {
  id         String       @id @default(cuid())
  playerId   String
  pollId     String
  
  // 투표 정보
  optionId   String      // options 배열 내 optionId와 매칭
  option     Json      // 실제 선택한 옵션 텍스트 (히스토리 추적용)
  
  // 베팅 정보
  betAmount  Int         @default(0)
  
  // 검증 정보
  ipAddress  String?
  userAgent  String?
  
  // 타임스탬프
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  // 참여보상
  rewardAssetId String?
  rewardAmount  Int?
  rewardAsset   Asset? @relation("PollLogRewardAsset", fields: [rewardAssetId], references: [id])

  // 메타데이터
  record   Json?
  
  // 관계
  player     Player      @relation(fields: [playerId], references: [id], onDelete: Cascade)
  poll       Poll        @relation(fields: [pollId], references: [id])
  rewardLogs RewardsLog[]

  // 인덱스
  @@index([playerId, pollId])
  @@index([pollId, optionId])
  @@index([createdAt])
}

model RewardsLog {
  id         String         @id @default(cuid())
  playerId   String

  // Asset 관련 필드 추가
  assetId        String?        // Asset ID
  balanceBefore  Int?          // 보상 전 잔액
  balanceAfter   Int?          // 보상 후 잔액

  questId    String?
  questLogId String?
  pollId     String?
  pollLogId  String?
  amount     Int
  reason     String?
  createdAt  DateTime       @default(now())

  player     Player         @relation(fields: [playerId], references: [id], onDelete: Cascade)
  asset          Asset?         @relation(fields: [assetId], references: [id])
  poll       Poll?          @relation(fields: [pollId], references: [id])
  pollLog    PollLog?       @relation(fields: [pollLogId], references: [id])
  quest      Quest?         @relation(fields: [questId], references: [id])
  questLog   QuestLog?      @relation(fields: [questLogId], references: [id])

  @@index([playerId, assetId])
  @@index([questId, pollId])
}

model Events {
  id              String        @id @default(cuid())
  category        EventCategory @default(other)
  title           String
  description     String?
  content         Json?
  url             String?
  status          EventStatus   @default(upcoming)
  bannerImg       String?
  bannerImg2      String?
  galleryImgs     String[]      @default([])
  detailImg       Json?
  saleStartDate   DateTime?
  saleEndDate     DateTime?
  price           Int?
  capacity        Int?
  ageLimit        Int?
  organizer       String?
  organizerImg    String?
  organizerUrl    String?
  contact         String?
  startDate       DateTime
  endDate         DateTime
  location        String?
  locationAddress String?
  locationImg     String?
  locationUrl     String?
  locationLat     Float?
  locationLng     Float?
  artist          String?
  artistImg       String?
  artistUrl       String?
  tags            String[]      @default([])
  hashtags        String[]      @default([])
  promotionText   String?
  promotionImg    String?
  isFeatured      Boolean       @default(false)
  viewCount       Int           @default(0)
  bookmarkCount   Int           @default(0)
  isActive        Boolean       @default(true)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([category, status, startDate])
  @@index([location, startDate])
  @@index([isFeatured, isActive, startDate])
}

model StoredFiles {
  id        String    @id @default(cuid())
  name      String?   @db.VarChar(255)
  url       String    @unique @db.VarChar(2048)
  type      String?   @db.VarChar(50)
  sourceUrl String?   @db.VarChar(2048)
  alt       String?   @db.VarChar(255)
  width     Int?
  height    Int?
  mimeType  String?   @db.VarChar(50)
  sizeBytes Int?
  metadata  Json?
  order     Int?      @default(0)
  purpose   String?   @db.VarChar(50)
  bucket    String    @db.VarChar(50)
  expiresAt DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@unique([sourceUrl, type])
  @@index([bucket, purpose])
  @@index([url, type])
}

model LoginAttemptLog {
  id        String   @id @default(cuid())
  userId    String?
  email     String?
  provider  String?
  success   Boolean
  error     String?
  ipAddress String?
  userAgent String?
  timestamp DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User?    @relation("UserLoginAttempts", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, success, timestamp])
  @@index([email, success, timestamp])
  @@index([provider, success, timestamp])
  @@index([ipAddress, timestamp])
}

model Payment {
  id                     String            @id @default(cuid())
  userId                 String?
  productTable           String
  productId              String
  productName            String
  productDefaultCurrency String
  amount                 Int
  quantity               Int
  currency               String
  payMethod              String
  easyPayProvider        String?
  cardProvider           String?
  cardInstallmentMonths  Int?
  cardInterestFree       Boolean?
  cardApproveNumber      String?
  cardNumber             String?
  status                 PaymentStatus     @default(PENDING)
  statusReason           String?
  paidAt                 DateTime?
  cancelledAt            DateTime?
  failedAt               DateTime?
  pgResponse             Json?
  metadata               Json?
  createdAt              DateTime          @default(now())
  updatedAt              DateTime          @updatedAt
  channelKey             String
  storeId                String
  promotionCode          String?
  isPromotionApplied     Boolean           @default(false)
  convertedPrice         Int?
  exchangeRate           Float?
  exchangeRateProvider   String?
  exchangeRateTimestamp  DateTime?
  originalProductPrice   Int?
  refundedAt             DateTime?
  cancelAmount           Int?
  redirectUrl            String?
  code                   String?
  message                String?
  paymentId              String?
  pgCode                 String?
  pgMessage              String?
  transactionType        String?
  txId                   String?
  postProcessResult      Json?
  postProcessResultAt    DateTime?
  receiverWalletAddress  String?
  needWallet             Boolean           @default(false)
  completedAt            DateTime?
  promotion              PaymentPromotion? @relation(fields: [promotionCode], references: [code])
  receiverWallet         Wallet?           @relation(fields: [receiverWalletAddress], references: [address])
  user                   User?             @relation(fields: [userId], references: [id])
  virtualAccount         VirtualAccount?
  webhookEvents          WebhookEvent[]

  @@index([userId])
  @@index([userId, status])
}

model PaymentPromotion {
  id            String                       @id @default(cuid())
  code          String                       @unique
  startDate     DateTime
  endDate       DateTime
  discountType  PaymentPromotionDiscountType @default(percentage)
  discountValue Int
  isActive      Boolean                      @default(true)
  createdAt     DateTime                     @default(now())
  updatedAt     DateTime                     @updatedAt
  payments      Payment[]

  @@index([code])
}

model WebhookEvent {
  id          String   @id @default(cuid())
  paymentId   String?
  payload     Json?
  createdAt   DateTime @default(now())
  description String?
  payment     Payment? @relation(fields: [paymentId], references: [id], onDelete: Cascade)
}

model VirtualAccount {
  id            String    @id @default(cuid())
  paymentId     String    @unique
  bankCode      String
  accountNumber String
  holderName    String
  expiresAt     DateTime
  depositedAt   DateTime?
  depositorName String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  payment       Payment   @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@index([accountNumber])
}

model ExchangeRate {
  id           String   @id @default(cuid())
  fromCurrency String
  toCurrency   String
  rate         Float
  provider     String
  createdAt    DateTime @default(now())

  @@index([fromCurrency, toCurrency])
}

model BlockchainNetwork {
  id                  String               @id @default(cuid())
  name                String               @unique
  chainId             Int                  @unique
  rpcUrl              String
  explorerUrl         String
  symbol              String
  isTestnet           Boolean              @default(true)
  isActive            Boolean              @default(true)
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  multicallAddress    String?
  collectionContracts CollectionContract[]
  factoryContracts    FactoryContract[]
  nfts                NFT[]
  assets              Asset[]
  assetsContracts     AssetsContract[]
  @@index([isTestnet, isActive])
}

model AssetsContract {
  id String @id @default(cuid())
  address String @unique
  version String
  description String?
  abi Json?
  bytecode String?

  networkId String
  network BlockchainNetwork @relation(fields: [networkId], references: [id])

  assets Asset[]

  creatorAddress String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([networkId])
}

enum AssetType {
  ONCHAIN
  OFFCHAIN
}

model Asset {
  id              String    @id @default(cuid())
  name            String
  symbol          String
  description     String?
  iconUrl         String?
  imageUrl        String?
  metadata        Json?     // JSON 형태로 메타데이터 저장
  assetType       AssetType
  contractAddress String?   // ONCHAIN인 경우 필수
  isActive        Boolean   @default(true)
  
  // Asset Function 관련
  selectors       String[]  @default([])  // bytes4를 string으로 저장
  abis            Json?     // {selector: abi} 형태로 저장

  // 관리자 정보
  creatorAddress String?

  // 에셋 컨트랙트
  assetId String?
  assetsContractAddress String?
  assetsContract AssetsContract? @relation(fields: [assetsContractAddress], references: [address])
  
  // 네트워크 정보
  networkId       String?
  network         BlockchainNetwork? @relation(fields: [networkId], references: [id])

  // 플레이어 정보
  playerAssets    PlayerAsset[]
  rewardsLogs     RewardsLog[]

  // 사용처
  pollBettingAssets Poll[] @relation("PollBettingAsset")
  pollParticipationRewardAssets Poll[] @relation("PollParticipationReward")
  questRewardAssets Quest[] @relation("QuestRewardAsset")
  pollLogRewardAssets PollLog[] @relation("PollLogRewardAsset")
  questLogRewardAssets QuestLog[] @relation("QuestLogRewardAsset")
  
  // 타임스탬프
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // 인덱스
  @@index([assetType, isActive])
  @@index([contractAddress])
  @@index([networkId])
}

model AssetTransaction {
  id          String   @id @default(cuid())
  success     Boolean
  assetId     String
  description String?
  metadata    Json?
  amount      Int?
  receiverAddress String?
  transactionHash String @unique
  createdAt   DateTime @default(now())
  
  @@index([assetId, success])
  @@index([transactionHash])
}

model FactoryContract {
  id                  String               @id @default(cuid())
  address             String
  networkId           String
  deployedAt          DateTime             @default(now())
  deployedBy          String?
  transactionHash     String?
  isActive            Boolean              @default(true)
  collections         String[]             @default([])
  abi                 Json?
  bytecode            String?
  collectionContracts CollectionContract[]
  network             BlockchainNetwork    @relation(fields: [networkId], references: [id])

  @@unique([address, networkId])
  @@index([networkId, isActive])
}

model EscrowWallet {
  id         String   @id @default(cuid())
  address    String   @unique
  privateKey String
  keyHash    String
  networkIds String[] @default([])
  isActive   Boolean  @default(true)
  balance    Json?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  nonce      String

  @@index([isActive])
}

model IpfsGroup {
  id        String     @id @default(cuid())
  pinataId  String     @unique @default(uuid())
  name      String     @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  files     IpfsFile[]

  @@index([name])
  @@index([pinataId])
}

model IpfsFile {
  id            String     @id @default(cuid())
  type          String     @default("nft-metadata")
  pinataId      String
  name          String
  cid           String
  size          Int
  numberOfFiles Int
  mimeType      String
  groupId       String?
  keyvalues     Json?
  vectorized    Boolean    @default(false)
  network       String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  gateway       String     @default("ipfs://")
  url           String     @default("ipfs://")
  group         IpfsGroup? @relation(fields: [groupId], references: [pinataId])

  @@index([pinataId])
  @@index([url])
  @@index([name])
  @@index([groupId])
  @@index([cid])
}

model Metadata {
  id                 String              @id @default(cuid())
  metadata           Json
  url                String              @default("ipfs://")
  collectionAddress  String?             @unique
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  type               MetadataType        @default(collection)
  tokenId            Int?
  collectionKey      String
  collectionContract CollectionContract? @relation("CollectionContractMetadata", fields: [collectionAddress], references: [address])

  @@unique([collectionAddress, tokenId])
  @@index([collectionAddress, tokenId])
  @@index([collectionAddress])
  @@index([url])
}

model CollectionContract {
  id          String            @id @default(cuid())
  address     String            @unique
  name        String
  symbol      String
  maxSupply   Int
  mintPrice   String
  baseURI     String
  contractURI String
  factoryId   String
  networkId   String
  createdBy   String            @default("admin")
  creatorAddress String          @default("0x58E1F072A8f41e1d476F06d73a6cB7b866e6f63B") 
  txHash      String?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  price       Int               @default(0)
  circulation Int               @default(1000)
  mintedCount Int               @default(0)
  artistId    String?
  key         String            @unique
  isListed    Boolean           @default(false)
  abi         Json?
  bytecode    String?
  isPaused    Boolean           @default(false)
  pauseAt     DateTime?
  unpauseAt   DateTime?
  artist      Artist?           @relation(fields: [artistId], references: [id])
  factory     FactoryContract   @relation(fields: [factoryId], references: [id])
  network     BlockchainNetwork @relation(fields: [networkId], references: [id])
  metadata    Metadata?         @relation("CollectionContractMetadata")
  nfts        NFT[]
  events      NFTEvent[]

  @@index([address, networkId])
  @@index([factoryId])
}

model NFT {
  id                  String             @id @default(cuid())
  tokenId             Int
  collectionId        String
  ownerAddress        String
  metadataUri         String?
  mintedAt            DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  transactionHash     String
  networkId           String
  name                String?
  description         String?
  imageUrl            String?
  attributes          Json?
  isListed            Boolean            @default(false)
  listingPrice        String?
  lastTransferredAt   DateTime?
  transferCount       Int                @default(0)
  isBurned            Boolean            @default(false)
  rarity              Float?
  tags                String[]
  category            String?
  creatorInfo         String?
  externalUrl         String?
  mintPrice           String?
  mintedBy            String?
  royaltyInfo         Json?
  currentOwnerAddress String?
  isLocked            Boolean            @default(false)
  lockedAt            DateTime?
  unlockAt            DateTime?
  unlockScheduledAt   DateTime?
  lockTransactionHash String?
  isStaked            Boolean            @default(false)
  stakedAt            DateTime?
  unstakeScheduledAt  DateTime?
  unstakedAt          DateTime?
  collection          CollectionContract @relation(fields: [collectionId], references: [id])
  network             BlockchainNetwork  @relation(fields: [networkId], references: [id])
  events              NFTEvent[]

  @@unique([collectionId, tokenId])
  @@index([collectionId, tokenId])
  @@index([collectionId])
  @@index([tokenId])
  @@index([currentOwnerAddress])
  @@index([ownerAddress])
}

model NFTEvent {
  id              String             @id @default(cuid())
  nftId           String
  collectionId    String
  eventType       String
  fromAddress     String?
  toAddress       String?
  price           String?
  transactionHash String
  timestamp       DateTime           @default(now())
  blockNumber     Int?
  collection      CollectionContract @relation(fields: [collectionId], references: [id])
  nft             NFT                @relation(fields: [nftId], references: [id])

  @@index([nftId])
  @@index([eventType])
  @@index([fromAddress, toAddress])
}

model Artist {
  id                  String               @id @default(cuid())
  name                String
  description         String?
  logoUrl             String?
  imageUrl            String?
  externalUrl         String?
  reportUrl           String?
  company             String?
  sns                 String[]             @default([])
  gallery             String[]             @default([])
  videos              String[]             @default([])
  music               String[]             @default([])
  events              String[]             @default([])
  additionalInfo      Json?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  members             ArtistMember[]
  collectionContracts CollectionContract[]
  messages            ArtistMessage[]
  polls               Poll[]               @relation("ArtistPolls")
  quests              Quest[]              @relation("ArtistQuests")

  @@index([name])
}

model ArtistMember {
  id             String    @id @default(cuid())
  artistId       String
  name           String
  role           String
  imageUrl       String?
  externalUrl    String?
  description    String?
  realName       String?
  birthDate      DateTime?
  birthPlace     String?
  nationality    String?
  height         Int?
  weight         Int?
  bloodType      String?
  constellation  String?
  sns            String[]  @default([])
  gallery        String[]  @default([])
  videos         String[]  @default([])
  music          String[]  @default([])
  additionalInfo Json?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  artist         Artist    @relation(fields: [artistId], references: [id])
}

model ArtistMessage {
  id             String    @id @default(cuid())
  artistId       String
  bannerUrl      String?
  externalUrl    String?
  isActive       Boolean   @default(true)
  startDate      DateTime?
  endDate        DateTime?
  message        String
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  artist         Artist    @relation(fields: [artistId], references: [id])
}

enum PaymentStatus {
  PENDING
  AWAITING_DEPOSIT
  PAID
  CANCELLED
  FAILED
  EXPIRED
  PARTIALLY_CANCELLED
  REFUNDED
  COMPLETED
}

enum PaymentPromotionDiscountType {
  percentage
  amount
}

enum RewardCurrency {
  points
  SGP
  SGT
}

enum EventCategory {
  concert
  fanmeeting
  fancamp
  festival
  exhibition
  other
}

enum EventStatus {
  upcoming
  ongoing
  completed
  cancelled
}

enum WalletStatus {
  ACTIVE
  INACTIVE
  LOCKED
}

enum MetadataType {
  collection
  nft
}
