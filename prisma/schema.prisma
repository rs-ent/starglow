generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

generator dbml {
  provider = "prisma-dbml-generator"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id            String            @id @default(cuid())
  name          String?
  email         String?           @unique
  emailVerified DateTime?
  image         String?
  role          String            @default("user")
  active        Boolean           @default(true)
  createdAt     DateTime          @default(now())
  lastLoginAt   DateTime?
  accounts      Account[]
  loginAttempts LoginAttemptLog[] @relation("UserLoginAttempts")
  payments      Payment[]
  player        Player?
  sessions      Session[]
  wallets       Wallet[]

  @@index([email, active])
  @@index([role, active])
  @@index([lastLoginAt])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId, provider])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique(map: "Session_sessionToken_unique")
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expires])
}

model Wallet {
  id             String       @id @default(cuid())
  userId         String
  address        String       @unique
  privateKey     String?
  network        String
  createdAt      DateTime     @default(now())
  default        Boolean      @default(false)
  primary        Int?         @default(0)
  lastAccessedAt DateTime     @updatedAt
  nickname       String?
  status         WalletStatus @default(ACTIVE)
  keyHash        String?
  nonce          String?
  payments       Payment[]
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, network, default])
  @@index([address, network])
}

model Player {
  id                String       @id @default(cuid())
  userId            String?      @unique
  telegramId        String?      @unique
  name              String?
  points            Int          @default(0)
  SGP               Int          @default(0)
  SGT               Int          @default(0)
  recommendedCount  Int          @default(0)
  recommenderId     String?
  recommenderName   String?
  recommenderMethod String?
  createdAt         DateTime     @default(now())
  lastConnectedAt   DateTime     @updatedAt
  user              User?        @relation(fields: [userId], references: [id], onDelete: Cascade)
  pollLogs          PollLog[]
  questLogs         QuestLog[]
  rewardLogs        RewardsLog[]

  @@index([userId, telegramId])
  @@index([points, SGP, SGT])
  @@index([recommenderId])
}

model Quest {
  id             String         @id @default(cuid())
  title          String
  description    String?
  url            String?
  icon           String?
  rewards        Int            @default(800)
  rewardCurrency RewardCurrency @default(points)
  startDate      DateTime?
  endDate        DateTime?
  permanent      Boolean        @default(false)
  visible        Boolean        @default(true)
  primary        Int?           @default(0)
  effects        String?
  type           String?
  questLogs      QuestLog[]
  rewardLogs     RewardsLog[]

  @@index([permanent, visible, startDate])
  @@index([type, visible])
  @@index([primary, visible])
}

model QuestLog {
  id             String         @id @default(cuid())
  playerId       String
  questId        String
  completed      Boolean        @default(false)
  completedAt    DateTime       @default(now())
  rewards        Int            @default(0)
  rewardCurrency RewardCurrency @default(points)
  createdAt      DateTime       @default(now())
  player         Player         @relation(fields: [playerId], references: [id], onDelete: Cascade)
  quest          Quest          @relation(fields: [questId], references: [id])
  rewardLogs     RewardsLog[]

  @@index([playerId, questId, completed])
  @@index([completedAt, rewardCurrency])
}

model Poll {
  id                      String       @id @default(cuid())
  title                   String
  titleShorten            String?
  options                 String[]     @default([])
  optionsShorten          String[]     @default([])
  bannerImg               String?
  startDate               DateTime     @default(now())
  endDate                 DateTime     @default(now())
  exposeInScheduleTab     Boolean      @default(false)
  openPromotionText       String?
  openPromotionImg        String?
  resultPromotionText     String?
  resultPromotionImg      String?
  totalVotes              Int          @default(0)
  totalVotesByOption      Int[]        @default([])
  totalBetsAmount         Int          @default(0)
  totalBetsAmountByOption Int[]        @default([])
  results                 Int[]        @default([])
  createdAt               DateTime     @default(now())
  updatedAt               DateTime     @updatedAt
  pollLogs                PollLog[]
  rewardLogs              RewardsLog[]

  @@index([startDate, endDate, exposeInScheduleTab])
  @@index([totalVotes, totalBetsAmount])
}

model PollLog {
  id         String       @id @default(cuid())
  playerId   String
  pollId     String
  option     String
  betAmount  Int          @default(0)
  createdAt  DateTime     @default(now())
  player     Player       @relation(fields: [playerId], references: [id], onDelete: Cascade)
  poll       Poll         @relation(fields: [pollId], references: [id])
  rewardLogs RewardsLog[]

  @@index([playerId, pollId])
  @@index([pollId, option])
}

model RewardsLog {
  id         String         @id @default(cuid())
  playerId   String
  questId    String?
  questLogId String?
  pollId     String?
  pollLogId  String?
  amount     Int
  currency   RewardCurrency @default(points)
  reason     String?
  createdAt  DateTime       @default(now())
  player     Player         @relation(fields: [playerId], references: [id], onDelete: Cascade)
  poll       Poll?          @relation(fields: [pollId], references: [id])
  pollLog    PollLog?       @relation(fields: [pollLogId], references: [id])
  quest      Quest?         @relation(fields: [questId], references: [id])
  questLog   QuestLog?      @relation(fields: [questLogId], references: [id])

  @@index([playerId, currency, createdAt])
  @@index([questId, pollId])
}

model Events {
  id              String        @id @default(cuid())
  category        EventCategory @default(other)
  title           String
  description     String?
  content         Json?
  url             String?
  status          EventStatus   @default(upcoming)
  bannerImg       String?
  bannerImg2      String?
  galleryImgs     String[]      @default([])
  detailImg       Json?
  saleStartDate   DateTime?
  saleEndDate     DateTime?
  price           Int?
  capacity        Int?
  ageLimit        Int?
  organizer       String?
  organizerImg    String?
  organizerUrl    String?
  contact         String?
  startDate       DateTime
  endDate         DateTime
  location        String?
  locationAddress String?
  locationImg     String?
  locationUrl     String?
  locationLat     Float?
  locationLng     Float?
  artist          String?
  artistImg       String?
  artistUrl       String?
  tags            String[]      @default([])
  hashtags        String[]      @default([])
  promotionText   String?
  promotionImg    String?
  isFeatured      Boolean       @default(false)
  viewCount       Int           @default(0)
  bookmarkCount   Int           @default(0)
  isActive        Boolean       @default(true)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([category, status, startDate])
  @@index([location, startDate])
  @@index([isFeatured, isActive, startDate])
}

model StoredFiles {
  id        String    @id @default(cuid())
  name      String?   @db.VarChar(255)
  url       String    @unique @db.VarChar(2048)
  type      String?   @db.VarChar(50)
  sourceUrl String?   @db.VarChar(2048)
  alt       String?   @db.VarChar(255)
  width     Int?
  height    Int?
  mimeType  String?   @db.VarChar(50)
  sizeBytes Int?
  metadata  Json?
  order     Int?      @default(0)
  purpose   String?   @db.VarChar(50)
  bucket    String    @db.VarChar(50)
  expiresAt DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@unique([sourceUrl, type])
  @@index([bucket, purpose])
  @@index([url, type])
}

model LoginAttemptLog {
  id        String   @id @default(cuid())
  userId    String?
  email     String?
  provider  String?
  success   Boolean
  error     String?
  ipAddress String?
  userAgent String?
  timestamp DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User?    @relation("UserLoginAttempts", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, success, timestamp])
  @@index([email, success, timestamp])
  @@index([provider, success, timestamp])
  @@index([ipAddress, timestamp])
}

model Payment {
  id                     String            @id @default(cuid())
  userId                 String?
  productTable           String
  productId              String
  productName            String
  productDefaultCurrency String
  amount                 Int
  quantity               Int
  currency               String
  payMethod              String
  easyPayProvider        String?
  cardProvider           String?
  cardInstallmentMonths  Int?
  cardInterestFree       Boolean?
  cardApproveNumber      String?
  cardNumber             String?
  status                 PaymentStatus     @default(PENDING)
  statusReason           String?
  paidAt                 DateTime?
  cancelledAt            DateTime?
  failedAt               DateTime?
  pgResponse             Json?
  metadata               Json?
  createdAt              DateTime          @default(now())
  updatedAt              DateTime          @updatedAt
  channelKey             String
  storeId                String
  promotionCode          String?
  isPromotionApplied     Boolean           @default(false)
  convertedPrice         Int?
  exchangeRate           Float?
  exchangeRateProvider   String?
  exchangeRateTimestamp  DateTime?
  originalProductPrice   Int?
  refundedAt             DateTime?
  cancelAmount           Int?
  redirectUrl            String?
  code                   String?
  message                String?
  paymentId              String?
  pgCode                 String?
  pgMessage              String?
  transactionType        String?
  txId                   String?
  postProcessResult      Json?
  postProcessResultAt    DateTime?
  receiverWalletAddress  String?
  needWallet             Boolean           @default(false)
  completedAt            DateTime?
  promotion              PaymentPromotion? @relation(fields: [promotionCode], references: [code])
  receiverWallet         Wallet?           @relation(fields: [receiverWalletAddress], references: [address])
  user                   User?             @relation(fields: [userId], references: [id])
  virtualAccount         VirtualAccount?
  webhookEvents          WebhookEvent[]

  @@index([userId])
  @@index([userId, status])
}

model PaymentPromotion {
  id            String                       @id @default(cuid())
  code          String                       @unique
  startDate     DateTime
  endDate       DateTime
  discountType  PaymentPromotionDiscountType @default(percentage)
  discountValue Int
  isActive      Boolean                      @default(true)
  createdAt     DateTime                     @default(now())
  updatedAt     DateTime                     @updatedAt
  payments      Payment[]

  @@index([code])
}

model WebhookEvent {
  id          String   @id @default(cuid())
  paymentId   String?
  payload     Json?
  createdAt   DateTime @default(now())
  description String?
  payment     Payment? @relation(fields: [paymentId], references: [id], onDelete: Cascade)
}

model VirtualAccount {
  id            String    @id @default(cuid())
  paymentId     String    @unique
  bankCode      String
  accountNumber String
  holderName    String
  expiresAt     DateTime
  depositedAt   DateTime?
  depositorName String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  payment       Payment   @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@index([accountNumber])
}

model ExchangeRate {
  id           String   @id @default(cuid())
  fromCurrency String
  toCurrency   String
  rate         Float
  provider     String
  createdAt    DateTime @default(now())

  @@index([fromCurrency, toCurrency])
}

model BlockchainNetwork {
  id                  String               @id @default(cuid())
  name                String               @unique
  chainId             Int                  @unique
  rpcUrl              String
  explorerUrl         String
  symbol              String
  isTestnet           Boolean              @default(true)
  isActive            Boolean              @default(true)
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  multicallAddress    String?
  collectionContracts CollectionContract[]
  factoryContracts    FactoryContract[]
  nfts                NFT[]

  @@index([isTestnet, isActive])
}

model FactoryContract {
  id                  String               @id @default(cuid())
  address             String
  networkId           String
  deployedAt          DateTime             @default(now())
  deployedBy          String?
  transactionHash     String?
  isActive            Boolean              @default(true)
  collections         String[]             @default([])
  abi                 Json?
  bytecode            String?
  collectionContracts CollectionContract[]
  network             BlockchainNetwork    @relation(fields: [networkId], references: [id])

  @@unique([address, networkId])
  @@index([networkId, isActive])
}

model EscrowWallet {
  id         String   @id @default(cuid())
  address    String   @unique
  privateKey String
  keyHash    String
  networkIds String[] @default([])
  isActive   Boolean  @default(true)
  balance    Json?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  nonce      String

  @@index([isActive])
}

model IpfsGroup {
  id        String     @id @default(cuid())
  pinataId  String     @unique @default(uuid())
  name      String     @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  files     IpfsFile[]

  @@index([name])
  @@index([pinataId])
}

model IpfsFile {
  id            String     @id @default(cuid())
  type          String     @default("nft-metadata")
  pinataId      String
  name          String
  cid           String
  size          Int
  numberOfFiles Int
  mimeType      String
  groupId       String?
  keyvalues     Json?
  vectorized    Boolean    @default(false)
  network       String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  gateway       String     @default("ipfs://")
  url           String     @default("ipfs://")
  group         IpfsGroup? @relation(fields: [groupId], references: [pinataId])

  @@index([pinataId])
  @@index([url])
  @@index([name])
  @@index([groupId])
  @@index([cid])
}

model Metadata {
  id                 String              @id @default(cuid())
  metadata           Json
  url                String              @default("ipfs://")
  collectionAddress  String?             @unique
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  type               MetadataType        @default(collection)
  tokenId            Int?
  collectionKey      String
  collectionContract CollectionContract? @relation("CollectionContractMetadata", fields: [collectionAddress], references: [address])

  @@unique([collectionAddress, tokenId])
  @@index([collectionAddress, tokenId])
  @@index([collectionAddress])
  @@index([url])
}

model CollectionContract {
  id          String            @id @default(cuid())
  address     String            @unique
  name        String
  symbol      String
  maxSupply   Int
  mintPrice   String
  baseURI     String
  contractURI String
  factoryId   String
  networkId   String
  createdBy   String            @default("admin")
  txHash      String?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  price       Int               @default(0)
  circulation Int               @default(1000)
  mintedCount Int               @default(0)
  artistId    String?
  key         String            @unique
  isListed    Boolean           @default(false)
  isPaused    Boolean           @default(false)
  pauseAt     DateTime?
  unpauseAt   DateTime?
  abi         Json?
  bytecode    String?
  artist      Artist?           @relation(fields: [artistId], references: [id])
  factory     FactoryContract   @relation(fields: [factoryId], references: [id])
  network     BlockchainNetwork @relation(fields: [networkId], references: [id])
  metadata    Metadata?         @relation("CollectionContractMetadata")
  nfts        NFT[]
  events      NFTEvent[]

  @@index([address, networkId])
  @@index([factoryId])
}

model NFT {
  id                  String             @id @default(cuid())
  tokenId             Int
  collectionId        String
  ownerAddress        String
  metadataUri         String?
  mintedAt            DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  transactionHash     String
  networkId           String
  name                String?
  description         String?
  imageUrl            String?
  attributes          Json?
  isLocked            Boolean            @default(false)
  lockedAt            DateTime?
  unlockScheduledAt   DateTime?
  unlockAt            DateTime?
  isStaked            Boolean            @default(false)
  stakedAt            DateTime?
  unstakeScheduledAt  DateTime?
  unstakedAt          DateTime?
  lockTransactionHash String?
  isListed            Boolean            @default(false)
  listingPrice        String?
  lastTransferredAt   DateTime?
  transferCount       Int                @default(0)
  isBurned            Boolean            @default(false)
  rarity              Float?
  tags                String[]
  category            String?
  creatorInfo         String?
  externalUrl         String?
  mintPrice           String?
  mintedBy            String?
  royaltyInfo         Json?
  currentOwnerAddress String?
  collection          CollectionContract @relation(fields: [collectionId], references: [id])
  network             BlockchainNetwork  @relation(fields: [networkId], references: [id])
  events              NFTEvent[]

  @@unique([collectionId, tokenId])
  @@index([collectionId, tokenId])
  @@index([collectionId])
  @@index([tokenId])
  @@index([currentOwnerAddress])
  @@index([ownerAddress])
}

model NFTEvent {
  id              String             @id @default(cuid())
  nftId           String
  collectionId    String
  eventType       String
  fromAddress     String?
  toAddress       String?
  price           String?
  transactionHash String
  timestamp       DateTime           @default(now())
  blockNumber     Int?
  collection      CollectionContract @relation(fields: [collectionId], references: [id])
  nft             NFT                @relation(fields: [nftId], references: [id])

  @@index([nftId])
  @@index([eventType])
  @@index([fromAddress, toAddress])
}

model Artist {
  id                  String               @id @default(cuid())
  name                String
  description         String?
  imageUrl            String?
  externalUrl         String?
  reportUrl           String?
  company             String?
  sns                 String[]             @default([])
  gallery             String[]             @default([])
  videos              String[]             @default([])
  music               String[]             @default([])
  events              String[]             @default([])
  additionalInfo      Json?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  members             ArtistMember[]
  collectionContracts CollectionContract[]

  @@index([name])
}

model ArtistMember {
  id             String    @id @default(cuid())
  artistId       String
  name           String
  role           String
  imageUrl       String?
  externalUrl    String?
  description    String?
  realName       String?
  birthDate      DateTime?
  birthPlace     String?
  nationality    String?
  height         Int?
  weight         Int?
  bloodType      String?
  constellation  String?
  sns            String[]  @default([])
  gallery        String[]  @default([])
  videos         String[]  @default([])
  music          String[]  @default([])
  additionalInfo Json?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  artist         Artist    @relation(fields: [artistId], references: [id])
}

enum PaymentStatus {
  PENDING
  AWAITING_DEPOSIT
  PAID
  CANCELLED
  FAILED
  EXPIRED
  PARTIALLY_CANCELLED
  REFUNDED
  COMPLETED
}

enum PaymentPromotionDiscountType {
  percentage
  amount
}

enum RewardCurrency {
  points
  SGP
  SGT
}

enum EventCategory {
  concert
  fanmeeting
  fancamp
  festival
  exhibition
  other
}

enum EventStatus {
  upcoming
  ongoing
  completed
  cancelled
}

enum WalletStatus {
  ACTIVE
  INACTIVE
  LOCKED
}

enum MetadataType {
  collection
  nft
}
